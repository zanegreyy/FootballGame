<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Football Pong</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        body {
            overflow: hidden;
            background-color: #222; /* Dark background */
        }
        h1 {
            font-family: sans-serif;
            font-size: 4rem;
            position: absolute;
            color: #fff; /* White text */
        }
        #player1Score {
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
        }
        #player2Score {
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
        }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
            background-color: #33ff00; /* Green button */
            color: #222; /* Dark text on button */
            border: none;
            border-radius: 5px;
        }
        #levelMessage {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
        }
        div {
            padding-top: 15px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <h1 id="player1Score">0</h1>
    <h1 id="player2Score">0</h1>
    <button id="startButton">Start Game!</button>
    <div id="levelMessage"></div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const levelMessage = document.getElementById('levelMessage');
        // getting the user ID from Telegram to award coins and nft 
        const urlParams = new URLSearchParams(window.location.search);
        const currentUserId = urlParams.get('user_id');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const keysPressed = [];
        const KEY_LEFT = 37;
        const KEY_RIGHT = 39;

        let touchStartX = 0;
        let isTouching = false; // Flag to track if the touch is active

        canvas.addEventListener('touchstart', function (e) {
            touchStartX = e.touches[0].clientX;
            isTouching = true;
        });

        canvas.addEventListener('touchmove', function (e) {
            e.preventDefault(); // Prevent scrolling on touch devices

            if (isTouching) {
                const touchX = e.touches[0].clientX;
                const deltaX = touchX - touchStartX;

                // Update paddle1 position based on touch movement
                paddle1.pos.x += deltaX;
                touchStartX = touchX; // Update touchStartX for next move
            }
        });

        canvas.addEventListener('touchend', function () {
            isTouching = false;
        });

        // Resize canvas on window resize
        window.addEventListener('resize', function () {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        window.addEventListener('keydown', function(e) {
            keysPressed[e.keyCode] = true;
        });

        window.addEventListener('keyup', function(e) {
            keysPressed[e.keyCode] = false;
        });

        function vec2(x, y) {
            return { x: x, y: y };
        }

        function Ball(pos, velocity, radius) {
            this.pos = pos;
            this.velocity = velocity;
            this.radius = radius;
            this.trail = [];

            this.update = function () {
                this.pos.x += this.velocity.x;
                this.pos.y += this.velocity.y;

                this.trail.push({ x: this.pos.x, y: this.pos.y });
                if (this.trail.length > 20) { // Increased trail length
                    this.trail.shift();
                }
            };

            this.draw = function () {
                // Draw the ball
                ctx.fillStyle = "white";
                ctx.strokeStyle = "white";
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Draw ball trail with fade-out and flame effect
                ctx.lineWidth = 12;
                for (let i = 0; i < this.trail.length - 1; i++) {
                    let alpha = 1 - i / this.trail.length; // Fade out effect
                    let hue = (i * 10) % 60; // Alternating flame colors (red to yellow)
                    
                    // Flame effect
                    let gradient = ctx.createLinearGradient(
                        this.trail[i].x, this.trail[i].y,
                        this.trail[i + 1].x, this.trail[i + 1].y
                    );
                    gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, ${alpha})`);
                    gradient.addColorStop(1, `hsla(${hue + 30}, 100%, 50%, ${alpha * 0.5})`);

                    ctx.beginPath();
                    ctx.strokeStyle = gradient;
                    ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    ctx.lineTo(this.trail[i + 1].x, this.trail[i + 1].y);
                    ctx.stroke();

                    // Add some flame particles
                    if (i % 3 === 0) {
                        let angle = Math.atan2(this.trail[i + 1].y - this.trail[i].y, this.trail[i + 1].x - this.trail[i].x);
                        let particleSize = 2 * alpha;
                        ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(
                            this.trail[i].x + Math.cos(angle + Math.PI / 2) * (Math.random() * 5),
                            this.trail[i].y + Math.sin(angle + Math.PI / 2) * (Math.random() * 5),
                            particleSize, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            };
        }


        
        function Paddle(pos, velocity, width, height) {
            this.pos = pos;
            this.velocity = velocity;
            this.width = width;
            this.height = height;
            this.score = 0;

            this.update = function () {
                if (keysPressed[KEY_LEFT]) {
                    this.pos.x -= this.velocity.x;
                }
                if (keysPressed[KEY_RIGHT]) {
                    this.pos.x += this.velocity.x;
                }
            };

            this.draw = function () {
                ctx.fillStyle = "#33ff00";
                ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
            };

            this.getHalfWidth = function() {
                return this.width / 2;
            };

            this.getHalfHeight = function() {
                return this.height / 2;
            };

            this.getCenter = function() {
                return vec2(
                    this.pos.x + this.getHalfWidth(),
                    this.pos.y + this.getHalfHeight()
                );
            };
        }

        function paddleCollisionWithTheEdges(paddle) {
            paddle.pos.x = Math.max(0, Math.min(paddle.pos.x, canvas.width - paddle.width));
        }

        function ballCollisionWithTheEdges(ball) {
            if (ball.pos.x + ball.radius >= canvas.width) {
                ball.velocity.x *= -1;
            }
            if (ball.pos.x - ball.radius <= 0) {
                ball.velocity.x *= -1;
            }
        }

function ballPaddleCollision(ball, paddle) {
    let dx = Math.abs(ball.pos.x - paddle.getCenter().x);
    let dy = Math.abs(ball.pos.y - paddle.getCenter().y);

    if (dx <= (ball.radius + paddle.getHalfWidth()) && dy <= (paddle.getHalfHeight() + ball.radius)) {
        // Check if the ball is moving towards the paddle
        if (ball.velocity.y > 0 && ball.pos.y < paddle.getCenter().y ||
            ball.velocity.y < 0 && ball.pos.y > paddle.getCenter().y) {
            ball.velocity.y *= -1;
            // Add some randomness to the bounce angle
            ball.velocity.x += (Math.random() - 0.5) * 1.9; // Adjust the randomness factor as needed
        }
    }
}


function player2AI(ball, paddle) {
    if (ball.velocity.y < 0) {
        let targetX = ball.pos.x - paddle.width / 2;
        let moveSpeed = paddle.velocity.x * levels[currentLevel].aiDifficulty;
        
        if (Math.abs(paddle.pos.x - targetX) > moveSpeed) {
            if (paddle.pos.x < targetX) {
                paddle.pos.x += moveSpeed;
            } else {
                paddle.pos.x -= moveSpeed;
            }
        }
        
        paddle.pos.x = Math.max(0, Math.min(paddle.pos.x, canvas.width - paddle.width));
    }
}

function respawnBall(ball) {
    ball.pos.x = canvas.width / 2;
    ball.pos.y = canvas.height / 2;
    ball.velocity.x = 0;
    ball.velocity.y = 0;
    ball.trail = [];

    let countdown = 1.5;
    const countdownInterval = setInterval(() => {
        if (countdown > 0) {
            levelMessage.textContent = `Respawning in ${countdown.toFixed(1)}...`;
            countdown -= 0.1;
        } else {
            clearInterval(countdownInterval);
            levelMessage.textContent = `Level ${currentLevel + 1}`;
            let speed = levels[currentLevel].ballSpeed;
            // Respawn with random horizontal direction, but always moving
            ball.velocity.x = (Math.random() > 0.5 ? 1 : -1) * speed;
            ball.velocity.y = (Math.random() > 0.5 ? 1 : -1) * speed;
        }
    }, 100);
}

function increaseScore(ball, paddle1, paddle2) {
    if (ball.pos.y <= -ball.radius) {
        paddle1.score += 1;
        document.getElementById('player1Score').innerHTML = paddle1.score;
        if (paddle1.score === 3 || paddle2.score === 3) {
            levelUp();
        } else {
            respawnBall(ball);
        }
    }

    if (ball.pos.y >= canvas.height + ball.radius) {
        paddle2.score += 1;
        document.getElementById('player2Score').innerHTML = paddle2.score;
        if (paddle1.score === 3 || paddle2.score === 3) {
            levelUp();
        } else {
            respawnBall(ball);
        }
    }
}

        function announceWinner(winner) {
            alert(winner + ' wins!');
            // Reset scores and level
            paddle1.score = 0;
            paddle2.score = 0;
            currentLevel = 0; // Reset to the first level
            document.getElementById('player1Score').innerHTML = 0;
            document.getElementById('player2Score').innerHTML = 0;
            // Reset the game state
            gameRunning = false;
            startButton.style.display = 'block';
            drawInitialScene();
        }
        function DrawGameScene() {
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(canvas.width, 0);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.lineTo(0, 0); // Close the path for the outer rectangle
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.arc(canvas.width / 2, canvas.height / 2, 50, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        const levels = [
            { ballSpeed: 6, paddleSpeed: 7, aiDifficulty: .5 },
            { ballSpeed: 7, paddleSpeed: 7, aiDifficulty: .62 },
            { ballSpeed: 7, paddleSpeed: 7, aiDifficulty: .75 },
            { ballSpeed: 8, paddleSpeed: 7, aiDifficulty: .82 },
            { ballSpeed: 8, paddleSpeed: 8, aiDifficulty: .85 }
        ];

        let currentLevel = 0;

async function levelUp() {
    if (paddle1.score === 3) {
        // Award 3 GoalBits for winning the level
        await awardGoalBits(currentUserId, 3);
        
        currentLevel++;
        if (currentLevel < levels.length) {
            const levelData = levels[currentLevel];
            ball.velocity.x = (ball.velocity.x > 0 ? 1 : -1) * levelData.ballSpeed;
            ball.velocity.y = (ball.velocity.y > 0 ? 1 : -1) * levelData.ballSpeed;
            paddle1.velocity.x = levelData.paddleSpeed;
            paddle2.velocity.x = levelData.paddleSpeed;
            // Reset scores
            paddle1.score = 0;
            paddle2.score = 0;
            document.getElementById('player1Score').innerHTML = 0;
            document.getElementById('player2Score').innerHTML = 0;
            levelMessage.textContent = `Level ${currentLevel + 1}`;
            respawnBall(ball);
        } else {
            // Award NFT for completing all levels
            await awardNFT(currentUserId);
            announceWinner("Player 1");
        }
    } else if (paddle2.score === 3) {
        showUnluckyMessage();
    }
}



function showUnluckyMessage() {
    gameRunning = false;
    levelMessage.textContent = "No burrito for you!";
    startButton.style.display = 'block';
    startButton.textContent = 'Restart Game';
}

// scoring system from DB 
async function awardGoalBits(userId, amount) {
    try {
        const response = await fetch('https://zaneegrey@github.io/FootballPong/index.html/award-goalbits', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ userId, amount }),
        });
        const data = await response.json();
        if (data.success) {
            console.log(`Awarded ${amount} GoalBits to user ${userId}`);
        } else {
            console.error('Failed to award GoalBits');
        }
    } catch (error) {
        console.error('Error awarding GoalBits:', error);
    }
}

async function awardNFT(userId) {
    try {
        const response = await fetch('https://zaneegrey@github.io/FootballPong/index.html/award-nft', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ userId }),
        });
        const data = await response.json();
        if (data.success) {
            console.log(`Awarded NFT to user ${userId}`);
        } else {
            console.error('Failed to award NFT');
        }
    } catch (error) {
        console.error('Error awarding NFT:', error);
    }
}

        const ball = new Ball(vec2(canvas.width / 2, canvas.height / 2), vec2(6, 6), 10);
        const paddle1 = new Paddle(vec2(canvas.width / 2 - 50, canvas.height - 30), vec2(15, 0), 60, 20); // Bottom Paddle
        const paddle2 = new Paddle(vec2(canvas.width / 2 - 50, 10), vec2(5, 0), 60, 20); // Top Paddle

        let gameRunning = false; // Track the state of the game

        function runGame() {
            ball.update();
            paddle1.update();
            paddleCollisionWithTheEdges(paddle1);
            ballCollisionWithTheEdges(ball);
            ballPaddleCollision(ball, paddle1);
            ballPaddleCollision(ball, paddle2);
            player2AI(ball, paddle2);
            increaseScore(ball, paddle1, paddle2);
            DrawGameScene();
            ball.draw();
            paddle1.draw();
            paddle2.draw();
        }

        function drawInitialScene() {
            // Clear the canvas
            ctx.fillStyle = "rgba(0,0,0,0.2)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white";

            // Draw initial message
            ctx.fillStyle = "#ffffff";
            ctx.font = "30px Arial";
            ctx.textAlign = "center";
            ctx.fillText("First to 3 wins a Burrito!", canvas.width / 2, canvas.height / 3);
            ctx.font = "20px Arial";
        }

        // Start the game loop
function gameLoop() {
    if (!gameLoop.isRunning) {
        gameLoop.isRunning = true;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (gameRunning) {
        runGame();
    }

    requestAnimationFrame(gameLoop);
}

        // Start game when button is clicked
startButton.addEventListener('click', function() {
    gameRunning = true;
    startButton.style.display = 'none';
    levelMessage.textContent = `Level ${currentLevel + 1}`;
    
    // Reset scores and level when restarting
    paddle1.score = 0;
    paddle2.score = 0;
    currentLevel = 0;
    document.getElementById('player1Score').innerHTML = 0;
    document.getElementById('player2Score').innerHTML = 0;
    
    // Reset ball and paddle positions
    respawnBall(ball);
    paddle1.pos.x = canvas.width / 2 - paddle1.width / 2;
    paddle2.pos.x = canvas.width / 2 - paddle2.width / 2;
    
    if (!gameLoop.isRunning) {
        gameLoop();
    }
});

    drawInitialScene(); // Draw initial scene before starting the game

    </script>
</body>
</html>
